//
//  UnifiedInvitationService.swift  
//  shigodeki
//
//  CTOÁ∑äÊÄ•„É™„Éï„Ç°„ÇØ„Çø„É™„É≥„Ç∞: Over-engineering„ÅÆËß£Ê∂à
//  1„Å§„ÅÆ„Ç≥„É¨„ÇØ„Ç∑„Éß„É≥„ÄÅ1„Å§„ÅÆÁúüÂÆü„ÅÆÊ∫ê„ÄÅ„Ç∑„É≥„Éó„É´„Å™ÂÆüË£Ö
//

import Foundation
import FirebaseFirestore
import FirebaseAuth

/// Áµ±‰∏Ä„Åï„Çå„ÅüÊãõÂæÖ„Ç∑„Çπ„ÉÜ„É† - KISSÂéüÂâá„ÅÆ‰ΩìÁèæ
/// Ë§áÈõëÊÄß„ÇíÊéíÈô§„Åó„ÄÅ‰øùÂÆàÊÄß„Å®„É¶„Éº„Ç∂„Éì„É™„ÉÜ„Ç£„Çí‰∏°Á´ã
class UnifiedInvitationService {
    private let db = Firestore.firestore()
    
    // Áµ±‰∏ÄÂÆöÊï∞ÔºàInviteCodeSpec„Å´Áµ±ÂêàÔºâ
    private var safeCharacters: String { InviteCodeSpec.safeCharacters }
    private var codeLength: Int { InviteCodeSpec.codeLength }
    
    /// ÊãõÂæÖ„Çø„Ç§„ÉóÂÆöÁæ©
    enum InvitationType: String, CaseIterable {
        case family = "family"
        case project = "project"
    }
    
    /// ÊãõÂæÖÊÉÖÂ†±ÊßãÈÄ†‰Ωì
    struct Invitation {
        let code: String
        let targetId: String
        let targetType: InvitationType
        let createdBy: String
        let createdAt: Date
        let expiresAt: Date
        let maxUses: Int
        let usedCount: Int
        let isActive: Bool
        
        var isValid: Bool {
            return isActive && 
                   expiresAt > Date() && 
                   usedCount < maxUses
        }
    }
    
    // MARK: - Public API
    
    /// ÊãõÂæÖ„Ç≥„Éº„ÉâÁîüÊàêÔºà„Ç∑„É≥„Éó„É´„ÄÅÂÆâÂÖ®„ÄÅÁ¢∫ÂÆüÔºâ
    /// - Parameters:
    ///   - targetId: ÊãõÂæÖÂØæË±°„ÅÆID„Éï„Ç°„Éü„É™„Éº„Åæ„Åü„ÅØ„Éó„É≠„Ç∏„Çß„ÇØ„ÉàÔºâ
    ///   - type: ÊãõÂæÖ„Çø„Ç§„Éó
    /// - Returns: 6Ê°Å„ÅÆÂÆâÂÖ®ÊñáÂ≠ó„Ç≥„Éº„ÉâÔºàINV-„Éó„É¨„Éï„Ç£„ÉÉ„ÇØ„Çπ„Å™„ÅóÔºâ
    func createInvitation(targetId: String, type: InvitationType) async throws -> String {
        guard let currentUserId = Auth.auth().currentUser?.uid else {
            throw InvitationError.userNotAuthenticated
        }
        
        let code = generateSafeCode()
        let now = Date()
        
        let invitationData: [String: Any] = [
            "code": code,
            "targetId": targetId,
            "targetType": type.rawValue,
            "createdBy": currentUserId,
            "createdAt": Timestamp(date: now),
            "expiresAt": Timestamp(date: now.addingTimeInterval(30 * 24 * 3600)), // 30Êó•
            "maxUses": 50,
            "usedCount": 0,
            "isActive": true
        ]
        
        // Âçò‰∏Ä‰øùÂ≠òÔºö1„Å§„ÅÆ„Ç≥„É¨„ÇØ„Ç∑„Éß„É≥„ÄÅ1„Å§„ÅÆÁúüÂÆü„ÅÆÊ∫ê
        try await db.collection("invitations_unified").document(code).setData(invitationData)
        
        print("‚úÖ [UnifiedInvitationService] Created invitation: \(code) -> \(type) \(targetId)")
        return code
    }
    
    /// ÊãõÂæÖ„Ç≥„Éº„ÉâÂèÇÂä†ÔºàÂéüÂ≠êÁöÑ„ÉªÂÜ™Á≠â„ÉªÂé≥ÂØÜÊ§úË®ºÔºâ
    /// - Parameter inputCode: „É¶„Éº„Ç∂„ÉºÂÖ•Âäõ„Ç≥„Éº„Éâ
    func joinWithInvitationCode(_ inputCode: String) async throws {
        guard let currentUserId = Auth.auth().currentUser?.uid else {
            throw InvitationError.userNotAuthenticated
        }
        
        // Áµ±‰∏ÄÊ≠£Ë¶èÂåñÔºà„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞Âº∑ÂåñÔºâ
        let code: String
        do {
            code = try normalizeCode(inputCode)
        } catch {
            throw InvitationError.invalidCode("Ê≠£Ë¶èÂåñ„Ç®„É©„Éº: \(error.localizedDescription)")
        }
        
        // 1. ÊãõÂæÖ„Ç≥„Éº„ÉâÊ§úË®º + ‰ΩøÁî®ÂõûÊï∞„ÉÅ„Çß„ÉÉ„ÇØ
        let inviteRef = db.collection("invitations_unified").document(code)
        let inviteDoc = try await inviteRef.getDocument()
        
        guard inviteDoc.exists, let data = inviteDoc.data() else {
            throw InvitationError.invalidOrExpired
        }
        
        let invitation = try parseInvitationData(code: code, data: data)
        
        // „Éá„Éê„ÉÉ„Ç∞: ÊãõÂæÖ„Ç≥„Éº„Éâ„ÅÆË©≥Á¥∞ÊÉÖÂ†±„Çí„É≠„Ç∞Âá∫ÂäõÔºàjoinÂá¶ÁêÜÔºâ
        print("üîç [UnifiedInvitationService] Join validation for \(code):")
        print("   - isActive: \(invitation.isActive)")
        print("   - expiresAt: \(invitation.expiresAt) (now: \(Date()))")
        print("   - usedCount/maxUses: \(invitation.usedCount)/\(invitation.maxUses)")
        print("   - targetId: \(invitation.targetId)")
        print("   - targetType: \(invitation.targetType)")
        
        // ÊúâÂäπÊÄß + ‰ΩøÁî®ÂõûÊï∞„ÅÆÂé≥ÂØÜ„ÉÅ„Çß„ÉÉ„ÇØ
        guard invitation.isActive && 
              invitation.expiresAt > Date() &&
              invitation.usedCount < invitation.maxUses else {
            print("‚ùå [UnifiedInvitationService] Join validation failed - isActive: \(invitation.isActive), expired: \(invitation.expiresAt <= Date()), used up: \(invitation.usedCount >= invitation.maxUses)")
            throw InvitationError.invalidOrExpired
        }
        
        // 2. ÂéüÂ≠êÁöÑÊõ¥Êñ∞Âá¶ÁêÜÔºàTransaction‰ΩøÁî® - ÊòéÁ§∫ÈÖçÂàóÊõ¥Êñ∞Ôºâ
        try await db.runTransaction({ (transaction, errorPointer) -> Any? in
            // ÂÜ™Á≠âÊÄß„ÉÅ„Çß„ÉÉ„ÇØÔºà„Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥ÂÜÖ„ÅßÂÆüË°åÔºâ
            print("üîç [UnifiedInvitationService] Checking existing membership in transaction for user \(currentUserId)")
            
            do {
                // ÊãõÂæÖ„Éâ„Ç≠„É•„É°„É≥„Éà„Çí„Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥ÂÜÖ„ÅßÂÜçÂèñÂæóÔºàÁ´∂ÂêàÂÆâÂÖ®„ÅÆ„Åü„ÇÅÔºâ
                let inviteSnap = try transaction.getDocument(inviteRef)
                guard let inviteData = inviteSnap.data() else {
                    throw InvitationError.invalidOrExpired
                }
                let currentUsedCount = (inviteData["usedCount"] as? Int) ?? invitation.usedCount

                let alreadyMember = try self.checkExistingMembershipInTransaction(
                    userId: currentUserId, 
                    invitation: invitation,
                    transaction: transaction
                )
                print("   - Already member: \(alreadyMember)")
                
                if alreadyMember {
                    // ÈáçË§áÂèÇÂä†„ÅØÊàêÂäüÊâ±„ÅÑÔºàÂÜ™Á≠âÊÄßÔºâ- ‰ΩøÁî®ÂõûÊï∞„ÅØÂ¢óÂä†„Åó„Å™„ÅÑ
                    print("‚ÑπÔ∏è [UnifiedInvitationService] User already member, skipping: \(code)")
                    return nil
                }
                
                // „É°„É≥„Éê„Éº„Ç∑„ÉÉ„ÉóËøΩÂä†Ôºà„Çø„Ç§„ÉóÂà•Âá¶ÁêÜ - ÊòéÁ§∫ÈÖçÂàóÊõ¥Êñ∞Ôºâ
                try self.addMembershipWithTransaction(
                    userId: currentUserId,
                    invitation: invitation,
                    transaction: transaction
                )
                
                // ‰ΩøÁî®ÂõûÊï∞Â¢óÂä†ÔºàÂé≥ÂØÜÊ§úË®ºÊ∏à„ÅøÔºâ
                transaction.updateData([
                    "usedCount": currentUsedCount + 1
                ], forDocument: inviteRef)
                
                return nil
            } catch {
                // „Ç®„É©„Éº„Çí errorPointer „Å´Ë®≠ÂÆö
                errorPointer?.pointee = error as NSError
                return nil
            }
        })
        
        print("‚úÖ [UnifiedInvitationService] Join completed: \(code)")
    }
    
    /// ÊãõÂæÖ„Ç≥„Éº„ÉâÊ§úË®ºÔºàUIÁî®„Éó„É¨„Éì„É•„ÉºÔºâ
    /// - Parameter inputCode: „É¶„Éº„Ç∂„ÉºÂÖ•Âäõ„Ç≥„Éº„Éâ
    /// - Returns: ÊãõÂæÖÊÉÖÂ†±ÔºàID„ÄÅÂêçÂâç„ÄÅ„Çø„Ç§„ÉóÔºâ
    func validateInvitationCode(_ inputCode: String) async throws -> (targetId: String, targetName: String, targetType: InvitationType) {
        let code = try normalizeCode(inputCode)
        let invitation = try await fetchInvitation(code)
        
        // „Éá„Éê„ÉÉ„Ç∞: ÊãõÂæÖ„Ç≥„Éº„Éâ„ÅÆË©≥Á¥∞ÊÉÖÂ†±„Çí„É≠„Ç∞Âá∫Âäõ
        print("üîç [UnifiedInvitationService] Invitation details for \(code):")
        print("   - isActive: \(invitation.isActive)")
        print("   - expiresAt: \(invitation.expiresAt) (now: \(Date()))")
        print("   - usedCount/maxUses: \(invitation.usedCount)/\(invitation.maxUses)")
        print("   - targetId: \(invitation.targetId)")
        print("   - targetType: \(invitation.targetType)")
        print("   - isValid: \(invitation.isValid)")
        
        guard invitation.isValid else {
            print("‚ùå [UnifiedInvitationService] Invitation invalid - isActive: \(invitation.isActive), expired: \(invitation.expiresAt <= Date()), used up: \(invitation.usedCount >= invitation.maxUses)")
            throw InvitationError.invalidOrExpired
        }
        
        // ÂØæË±°„ÅÆÂêçÂâç„ÇíÂèñÂæó
        let targetName = try await fetchTargetName(invitation.targetId, type: invitation.targetType)
        
        return (targetId: invitation.targetId, targetName: targetName, targetType: invitation.targetType)
    }
    
    // MARK: - Private Implementation
    
    /// ÂÆâÂÖ®„Ç≥„Éº„ÉâÁîüÊàêÔºàÁµ±‰∏Ä‰ªïÊßòÊ∫ñÊã†Ôºâ
    private func generateSafeCode() -> String {
        return String((0..<codeLength).map { _ in 
            safeCharacters.randomElement()! 
        })
    }
    
    /// Áµ±‰∏ÄÊ≠£Ë¶èÂåñÔºàÊñ∞Ê≠£Ë¶èÂåñ„Ç∑„Çπ„ÉÜ„É†‰ΩøÁî®Ôºâ
    private func normalizeCode(_ input: String) throws -> String {
        return try InvitationCodeNormalizer.normalize(input)
    }
    
    /// ÊãõÂæÖÊÉÖÂ†±ÂèñÂæó
    private func fetchInvitation(_ code: String) async throws -> Invitation {
        let doc = try await db.collection("invitations_unified").document(code).getDocument()
        
        guard doc.exists, let data = doc.data() else {
            throw InvitationError.invalidOrExpired
        }
        
        guard let targetId = data["targetId"] as? String,
              let targetTypeString = data["targetType"] as? String,
              let targetType = InvitationType(rawValue: targetTypeString),
              let createdBy = data["createdBy"] as? String,
              let createdAtTimestamp = data["createdAt"] as? Timestamp,
              let expiresAtTimestamp = data["expiresAt"] as? Timestamp,
              let maxUses = data["maxUses"] as? Int,
              let usedCount = data["usedCount"] as? Int,
              let isActive = data["isActive"] as? Bool else {
            throw InvitationError.corruptedData
        }
        
        return Invitation(
            code: code,
            targetId: targetId,
            targetType: targetType,
            createdBy: createdBy,
            createdAt: createdAtTimestamp.dateValue(),
            expiresAt: expiresAtTimestamp.dateValue(),
            maxUses: maxUses,
            usedCount: usedCount,
            isActive: isActive
        )
    }
    
    /// ÂØæË±°ÂêçÂèñÂæó
    private func fetchTargetName(_ targetId: String, type: InvitationType) async throws -> String {
        switch type {
        case .family:
            let doc = try await db.collection("families").document(targetId).getDocument()
            return doc.data()?["name"] as? String ?? "Unknown Family"
        case .project:
            let doc = try await db.collection("projects").document(targetId).getDocument()
            return doc.data()?["name"] as? String ?? "Unknown Project"
        }
    }
    
    /// „Éï„Ç°„Éü„É™„ÉºÂèÇÂä†Âá¶ÁêÜ
    private func joinFamily(_ familyId: String, userId: String) async throws {
        // „Éï„Ç°„Éü„É™„Éº„É°„É≥„Éê„ÉºËøΩÂä†
        try await db.collection("families").document(familyId).updateData([
            "members": FieldValue.arrayUnion([userId])
        ])
        
        // „É¶„Éº„Ç∂„Éº„ÅÆfamilyIdsÊõ¥Êñ∞
        try await db.collection("users").document(userId).updateData([
            "familyIds": FieldValue.arrayUnion([familyId])
        ])
    }
    
    /// „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÂèÇÂä†Âá¶ÁêÜ
    private func joinProject(_ projectId: String, userId: String) async throws {
        // „Éó„É≠„Ç∏„Çß„ÇØ„Éà„É°„É≥„Éê„ÉºËøΩÂä†
        try await db.collection("projects").document(projectId).updateData([
            "memberIds": FieldValue.arrayUnion([userId])
        ])
        
        // „É°„É≥„Éê„ÉºË©≥Á¥∞‰ΩúÊàê
        try await db.collection("projects").document(projectId)
            .collection("members").document(userId).setData([
                "userId": userId,
                "projectId": projectId,
                "role": "editor",
                "joinedAt": FieldValue.serverTimestamp()
            ], merge: true)
    }
    
    /// ÊãõÂæÖ„Éá„Éº„ÇøËß£ÊûêÔºà„Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥ÂÜÖÁî®Ôºâ
    private func parseInvitationData(code: String, data: [String: Any]) throws -> Invitation {
        guard let targetId = data["targetId"] as? String,
              let targetTypeString = data["targetType"] as? String,
              let targetType = InvitationType(rawValue: targetTypeString),
              let createdBy = data["createdBy"] as? String,
              let createdAtTimestamp = data["createdAt"] as? Timestamp,
              let expiresAtTimestamp = data["expiresAt"] as? Timestamp,
              let maxUses = data["maxUses"] as? Int,
              let usedCount = data["usedCount"] as? Int,
              let isActive = data["isActive"] as? Bool else {
            throw InvitationError.corruptedData
        }
        
        return Invitation(
            code: code,
            targetId: targetId,
            targetType: targetType,
            createdBy: createdBy,
            createdAt: createdAtTimestamp.dateValue(),
            expiresAt: expiresAtTimestamp.dateValue(),
            maxUses: maxUses,
            usedCount: usedCount,
            isActive: isActive
        )
    }
    
    /// Êó¢Â≠ò„É°„É≥„Éê„Éº„Ç∑„ÉÉ„Éó„ÉÅ„Çß„ÉÉ„ÇØÔºàÂÜ™Á≠âÊÄß‰øùË®ºÔºâ
    private func checkExistingMembership(
        userId: String, 
        invitation: Invitation
    ) async throws -> Bool {
        switch invitation.targetType {
        case .family:
            let familyRef = db.collection("families").document(invitation.targetId)
            let familyDoc = try await familyRef.getDocument()
            if let familyData = familyDoc.data(),
               let members = familyData["members"] as? [String] {
                return members.contains(userId)
            }
            return false
            
        case .project:
            let projectRef = db.collection("projects").document(invitation.targetId)
            let projectDoc = try await projectRef.getDocument()
            if let projectData = projectDoc.data(),
               let memberIds = projectData["memberIds"] as? [String] {
                return memberIds.contains(userId)
            }
            return false
        }
    }
    
    /// „É°„É≥„Éê„Éº„Ç∑„ÉÉ„ÉóËøΩÂä†Ôºà„Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥ÂÜÖÂÆüË°åÔºâ
    private func addMembership(
        userId: String,
        invitation: Invitation,
        transaction: Transaction
    ) throws {
        switch invitation.targetType {
        case .family:
            try addFamilyMembership(userId: userId, familyId: invitation.targetId, transaction: transaction)
            
        case .project:
            // „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÂèÇÂä†„ÅØÂÆ∂ÊóèÂèÇÂä†„ÇÇÂøÖË¶Å
            try addProjectMembership(userId: userId, invitation: invitation, transaction: transaction)
        }
    }
    
    /// ÂÆ∂Êóè„É°„É≥„Éê„Éº„Ç∑„ÉÉ„ÉóËøΩÂä†Ôºà„Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥ÂÜÖÔºâ
    private func addFamilyMembership(
        userId: String, 
        familyId: String, 
        transaction: Transaction
    ) throws {
        let familyRef = db.collection("families").document(familyId)
        transaction.updateData([
            "members": FieldValue.arrayUnion([userId])
        ], forDocument: familyRef)
        
        let userRef = db.collection("users").document(userId)
        transaction.updateData([
            "familyIds": FieldValue.arrayUnion([familyId])
        ], forDocument: userRef)
    }
    
    /// „Éó„É≠„Ç∏„Çß„ÇØ„Éà„É°„É≥„Éê„Éº„Ç∑„ÉÉ„ÉóËøΩÂä†ÔºàÂÆ∂ÊóèÂèÇÂä†Ëæº„ÅøÔºâ
    private func addProjectMembership(
        userId: String, 
        invitation: Invitation, 
        transaction: Transaction
    ) throws {
        let projectRef = db.collection("projects").document(invitation.targetId)
        let projectDoc = try transaction.getDocument(projectRef)
        
        guard let projectData = projectDoc.data(),
              let familyId = projectData["familyId"] as? String else {
            throw InvitationError.joinFailed("„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆfamilyIdÂèñÂæó„Ç®„É©„Éº")
        }
        
        // 1. ÂÖà„Å´ÂÆ∂Êóè„É°„É≥„Éê„Éº„Ç∑„ÉÉ„Éó„ÇíÁ¢∫‰øù
        try addFamilyMembership(userId: userId, familyId: familyId, transaction: transaction)
        
        // 2. „Éó„É≠„Ç∏„Çß„ÇØ„Éà„É°„É≥„Éê„Éº„Ç∑„ÉÉ„ÉóËøΩÂä†
        transaction.updateData([
            "memberIds": FieldValue.arrayUnion([userId])
        ], forDocument: projectRef)
        
        // 3. „Éó„É≠„Ç∏„Çß„ÇØ„Éà„É°„É≥„Éê„ÉºË©≥Á¥∞‰ΩúÊàê
        let memberRef = projectRef.collection("members").document(userId)
        transaction.setData([
            "userId": userId,
            "projectId": invitation.targetId,
            "role": "editor",
            "joinedAt": FieldValue.serverTimestamp(),
            "invitedBy": invitation.createdBy
        ], forDocument: memberRef, merge: true)
    }
    
    // MARK: - WriteBatch Methods (Firebase‰∫íÊèõÊÄßÂØæÂøú)
    
    /// „É°„É≥„Éê„Éº„Ç∑„ÉÉ„ÉóËøΩÂä†ÔºàWriteBatch‰ΩøÁî®Ôºâ
    private func addMembershipWithBatch(
        userId: String,
        invitation: Invitation,
        batch: WriteBatch
    ) async throws {
        switch invitation.targetType {
        case .family:
            try addFamilyMembershipWithBatch(userId: userId, familyId: invitation.targetId, batch: batch)
            
        case .project:
            // „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÂèÇÂä†„ÅØÂÆ∂ÊóèÂèÇÂä†„ÇÇÂøÖË¶Å
            try await addProjectMembershipWithBatch(userId: userId, invitation: invitation, batch: batch)
        }
    }
    
    /// ÂÆ∂Êóè„É°„É≥„Éê„Éº„Ç∑„ÉÉ„ÉóËøΩÂä†ÔºàWriteBatch‰ΩøÁî®Ôºâ
    private func addFamilyMembershipWithBatch(
        userId: String, 
        familyId: String, 
        batch: WriteBatch
    ) throws {
        let familyRef = db.collection("families").document(familyId)
        batch.updateData([
            "members": FieldValue.arrayUnion([userId])
        ], forDocument: familyRef)
        
        let userRef = db.collection("users").document(userId)
        batch.updateData([
            "familyIds": FieldValue.arrayUnion([familyId])
        ], forDocument: userRef)
    }
    
    /// „Éó„É≠„Ç∏„Çß„ÇØ„Éà„É°„É≥„Éê„Éº„Ç∑„ÉÉ„ÉóËøΩÂä†ÔºàWriteBatch‰ΩøÁî® + ÂÆ∂ÊóèÂèÇÂä†Ëæº„ÅøÔºâ
    private func addProjectMembershipWithBatch(
        userId: String, 
        invitation: Invitation, 
        batch: WriteBatch
    ) async throws {
        let projectRef = db.collection("projects").document(invitation.targetId)
        let projectDoc = try await projectRef.getDocument()
        
        guard let projectData = projectDoc.data(),
              let familyId = projectData["familyId"] as? String else {
            throw InvitationError.joinFailed("„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆfamilyIdÂèñÂæó„Ç®„É©„Éº")
        }
        
        // 1. ÂÖà„Å´ÂÆ∂Êóè„É°„É≥„Éê„Éº„Ç∑„ÉÉ„Éó„ÇíÁ¢∫‰øù
        try addFamilyMembershipWithBatch(userId: userId, familyId: familyId, batch: batch)
        
        // 2. „Éó„É≠„Ç∏„Çß„ÇØ„Éà„É°„É≥„Éê„Éº„Ç∑„ÉÉ„ÉóËøΩÂä†
        batch.updateData([
            "memberIds": FieldValue.arrayUnion([userId])
        ], forDocument: projectRef)
        
        // 3. „Éó„É≠„Ç∏„Çß„ÇØ„Éà„É°„É≥„Éê„ÉºË©≥Á¥∞‰ΩúÊàê
        let memberRef = projectRef.collection("members").document(userId)
        batch.setData([
            "userId": userId,
            "projectId": invitation.targetId,
            "role": "editor",
            "joinedAt": FieldValue.serverTimestamp(),
            "invitedBy": invitation.createdBy
        ], forDocument: memberRef, merge: true)
    }
    
    // MARK: - Transaction Methods (ÊòéÁ§∫ÈÖçÂàóÊõ¥Êñ∞)
    
    /// „Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥ÂÜÖ„Åß„ÅÆÂÜ™Á≠âÊÄß„ÉÅ„Çß„ÉÉ„ÇØ
    private func checkExistingMembershipInTransaction(
        userId: String,
        invitation: Invitation,
        transaction: Transaction
    ) throws -> Bool {
        switch invitation.targetType {
        case .family:
            let familyRef = db.collection("families").document(invitation.targetId)
            let familyDoc = try transaction.getDocument(familyRef)
            if let members = familyDoc.data()?["members"] as? [String] {
                return members.contains(userId)
            }
            return false
            
        case .project:
            let projectRef = db.collection("projects").document(invitation.targetId)
            let memberRef = projectRef.collection("members").document(userId)
            let memberDoc = try transaction.getDocument(memberRef)
            return memberDoc.exists
        }
    }
    
    /// „É°„É≥„Éê„Éº„Ç∑„ÉÉ„ÉóËøΩÂä†ÔºàTransaction‰ΩøÁî® - ÊòéÁ§∫ÈÖçÂàóÊõ¥Êñ∞Ôºâ
    private func addMembershipWithTransaction(
        userId: String,
        invitation: Invitation,
        transaction: Transaction
    ) throws {
        switch invitation.targetType {
        case .family:
            try addFamilyMembershipWithTransaction(userId: userId, familyId: invitation.targetId, transaction: transaction)
            
        case .project:
            // „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÂèÇÂä†„ÅØÂÆ∂ÊóèÂèÇÂä†„ÇÇÂøÖË¶Å
            try addProjectMembershipWithTransaction(userId: userId, invitation: invitation, transaction: transaction)
        }
    }
    
    /// ÂÆ∂Êóè„É°„É≥„Éê„Éº„Ç∑„ÉÉ„ÉóËøΩÂä†ÔºàTransaction‰ΩøÁî® - ÊòéÁ§∫ÈÖçÂàóÊõ¥Êñ∞Ôºâ
    private func addFamilyMembershipWithTransaction(
        userId: String, 
        familyId: String, 
        transaction: Transaction
    ) throws {
        // Firestore„Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥Âà∂Á¥Ñ: „Åô„Åπ„Å¶„ÅÆread„ÇíÊúÄÂàù„Å´ÂÆüË°å„Åó„ÄÅ„Åù„ÅÆÂæå„Å´write„ÇíË°å„ÅÜ
        // 1) ÂÖà„Å´ÂøÖË¶Å„Å™„Éâ„Ç≠„É•„É°„É≥„Éà„Çí„Åô„Åπ„Å¶ÂèñÂæó
        let familyRef = db.collection("families").document(familyId)
        let userRef = db.collection("users").document(userId)

        let familyDoc = try transaction.getDocument(familyRef)
        let userDoc = try transaction.getDocument(userRef)

        // 2) Êñ∞„Åó„ÅÑÈÖçÂàóÂÄ§„ÇíË®àÁÆóÔºàÈáçË§á„ÅØÈÅø„Åë„ÇãÔºâ
        var nextMembers = (familyDoc.data()?["members"] as? [String]) ?? []
        if !nextMembers.contains(userId) {
            nextMembers.append(userId)
        }

        var nextFamilyIds = (userDoc.data()?["familyIds"] as? [String]) ?? []
        if !nextFamilyIds.contains(familyId) {
            nextFamilyIds.append(familyId)
        }

        // 3) ÂøÖË¶Å„Å™Â†¥Âêà„ÅÆ„Åøwrite„ÇíÂÆüË°å
        if let currentMembers = familyDoc.data()?["members"] as? [String] {
            if currentMembers != nextMembers {
                transaction.updateData(["members": nextMembers], forDocument: familyRef)
            }
        } else {
            transaction.updateData(["members": nextMembers], forDocument: familyRef)
        }

        if let currentFamilyIds = userDoc.data()?["familyIds"] as? [String] {
            if currentFamilyIds != nextFamilyIds {
                transaction.updateData(["familyIds": nextFamilyIds], forDocument: userRef)
            }
        } else {
            transaction.updateData(["familyIds": nextFamilyIds], forDocument: userRef)
        }
    }
    
    /// „Éó„É≠„Ç∏„Çß„ÇØ„Éà„É°„É≥„Éê„Éº„Ç∑„ÉÉ„ÉóËøΩÂä†ÔºàTransaction‰ΩøÁî® - ÊòéÁ§∫ÈÖçÂàóÊõ¥Êñ∞ + ÂÆ∂ÊóèÂèÇÂä†Ëæº„ÅøÔºâ
    private func addProjectMembershipWithTransaction(
        userId: String, 
        invitation: Invitation, 
        transaction: Transaction
    ) throws {
        let projectRef = db.collection("projects").document(invitation.targetId)
        let projectDoc = try transaction.getDocument(projectRef)
        
        guard let projectData = projectDoc.data(),
              let familyId = projectData["familyId"] as? String else {
            throw InvitationError.joinFailed("„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆfamilyIdÂèñÂæó„Ç®„É©„Éº")
        }
        
        // ÂÖà„Å´ÂÆ∂ÊóèÂèÇÂä†„ÇíÂÆüË°å
        try addFamilyMembershipWithTransaction(userId: userId, familyId: familyId, transaction: transaction)
        
        // „Éó„É≠„Ç∏„Çß„ÇØ„Éà„É°„É≥„Éê„ÉºËøΩÂä†
        let memberRef = projectRef.collection("members").document(userId)
        transaction.setData([
            "userId": userId,
            "projectId": invitation.targetId,
            "role": "editor",
            "joinedAt": FieldValue.serverTimestamp(),
            "invitedBy": invitation.createdBy
        ], forDocument: memberRef, merge: true)
    }
}

// MARK: - Error Definitions

/// Áµ±‰∏ÄÊãõÂæÖ„Ç®„É©„ÉºÔºà4Á®ÆÈ°û„Å´Êï¥ÁêÜÔºâ
enum InvitationError: LocalizedError {
    case userNotAuthenticated
    case invalidCode(String)
    case invalidOrExpired  
    case corruptedData
    case joinFailed(String)
    
    var errorDescription: String? {
        switch self {
        case .userNotAuthenticated:
            return "Ë™çË®º„ÅåÂøÖË¶Å„Åß„Åô"
        case .invalidCode(let reason):
            return "ÁÑ°Âäπ„Å™ÊãõÂæÖ„Ç≥„Éº„Éâ: \(reason)"
        case .invalidOrExpired:
            return "ÁÑ°Âäπ„Åæ„Åü„ÅØÊúüÈôêÂàá„Çå„ÅÆÊãõÂæÖ„Ç≥„Éº„Éâ„Åß„Åô"
        case .corruptedData:
            return "ÊãõÂæÖ„Éá„Éº„Çø„ÅåÁ†¥Êêç„Åó„Å¶„ÅÑ„Åæ„Åô"
        case .joinFailed(let reason):
            return "ÂèÇÂä†„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: \(reason)"
        }
    }
}
